<?php

/**
 * @file
 * Contains votingapi.module.
 *
 * A generalized voting API for Drupal.
 *
 * Maintains and provides an interface for a shared bin of vote and rating
 * data. Modules can cast votes with arbitrary properties and VotingAPI will
 * total them automatically. Support for basic anonymous voting by IP address,
 * multi-criteria voting, arbitrary aggregation functions, etc.
 */

use Drupal\Core\Routing\RouteMatchInterface;

/**
 * Implements hook_help().
 */
function votingapi_help($route_name, RouteMatchInterface $route_match) {
  switch ($route_name) {
    // Main module help for the votingapi module.
    case 'help.page.votingapi':
      $output = '';
      $output .= '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('Voting API') . '</p>';
      return $output;

    default:
  }
}

/**
 * Implements hook_entity_delete().
 *
 * Delete all votes and cache entries for the deleted entities
 */
function votingapi_entity_delete(Drupal\Core\Entity\EntityInterface $entity) {
  //  ##############
  //  $ids = array($entity->id());
  //  $type = $entity->getEntityTypeId();
  //  ResultCriteria::byEntity($type, $ids)->delete();
  //  Criteria::byEntity($type, $ids)->delete();
  //  ##############

//  // If a vote is deleted, the results need to be updated.
//  if ($entity instanceof \Drupal\votingapi\VoteInterface) {
//    Drupal::service('plugin.manager.votingapi.result')
//      ->recalculateResults($entity->getVotedEntityType(), $entity->getVotedEntityId());
//  }
//  // For any other entity, remove any votes and results.
//  else {
//    $votes = Drupal::entityQuery('vote')
//      ->condition('entity_type', $entity->getEntityTypeId())
//      ->condition('entity_id', $entity->id())
//      ->execute();
//    if (!empty($votes)) {
//      entity_delete_multiple('vote', $votes);
//    }
//    db_delete('votingapi_results')
//      ->condition('entity_type', $entity->getEntityTypeId())
//      ->condition('entity_id', $entity->id())
//      ->execute();
//  }
}

/**
 * Implements hook_ENTITY_TYPE_insert().
 */
function votingapi_vote_insert(Drupal\votingapi\VoteInterface $vote) {
  // Update voting results when a new vote is cast.
  if (Drupal::config('votingapi.settings')
      ->get('calculation_schedule') == 'immediate'
  ) {
//    Drupal::service('plugin.manager.votingapi.result')
//      ->recalculateResults($vote->getVotedEntityType(), $vote->getVotedEntityId());
  }
}

/**
 * Implements hook_cron().
 *
 * Allows db-intensive recalculations to be deferred until cron-time.
 */
function votingapi_cron() {
  $config = Drupal::config('votingapi.settings');

  // Recalculate results for any entities that have gotten votes since the last
  // run.
  if ($config->get('calculation_schedule') == 'cron') {
    // APPROACH 1
    //    $last_cron = Drupal::state()->get('votingapi.last_cron', 0);
    //    $results = Drupal::entityQueryAggregate('vote')
    //      ->condition('created', $last_cron, '>')
    //      ->groupBy('entity_type')
    //      ->groupBy('entity_id')
    //      ->execute();
    //    $manager = Drupal::service('plugin.manager.votingapi.result');
    //    foreach ($results as $entity) {
    //      $manager->recalculateResults($entity['entity_type'], $entity['entity_id']);
    //    }
    //    Drupal::state()->set('votingapi.last_cron', REQUEST_TIME);
    //
    // APPROACH 2
    //  $time = REQUEST_TIME;
    //  $last_cron = \Drupal::state()->get('votingapi_last_cron', 0);
    //  $result = db_query('SELECT DISTINCT entity_type, entity_id FROM {votingapi_vote} WHERE timestamp > :timestamp', array(':timestamp' => $last_cron));
    //  foreach ($result as $content) {
    //    votingapi_recalculate_results($content->entity_type, $content->entity_id, TRUE);
    //  }
    //  \Drupal::state()->set('votingapi_last_cron', $time);
  }
}

/**
 * Returns metadata about tags, value_types, and results defined by vote modules.
 *
 * If your module needs to determine what existing tags, value_types, etc., are
 * being supplied by other modules, call this function. Querying the votingapi
 * tables for this information directly is discouraged, as values may not appear
 * consistently. (For example, 'average' does not appear in the cache table until
 * votes have actually been cast in the cache table.)
 *
 * Three major bins of data are stored: tags, value_types, and functions. Each
 * entry in these bins is keyed by the value stored in the actual VotingAPI
 * tables, and contains an array with (minimally) 'name' and 'description' keys.
 * Modules can add extra keys to their entries if desired.
 *
 * This metadata can be modified or expanded using hook_votingapi_metadata_alter().
 *
 * @param bool $reset
 *   Force get a fresh data.
 *
 * @return array
 *   An array of metadata defined by VotingAPI and altered by vote modules.
 *
 * @see hook_votingapi_metadata_alter()
 */
function votingapi_metadata($reset = FALSE) {
  static $data;
  if ($reset || !isset($data)) {
    $data = array(
      'tags' => array(
        'vote' => array(
          'name' => t('Normal vote'),
          'description' => t('The default tag for votes on content. If multiple votes with different tags are being cast on a piece of content, consider casting a "summary" vote with this tag as well.'),
        ),
      ),
      'value_types' => array(
        'percent' => array(
          'name' => t('Percent'),
          'description' => t('Votes in a specific range. Values are stored in a 1-100 range, but can be represented as any scale when shown to the user.'),
        ),
        'points' => array(
          'name' => t('Points'),
          'description' => t('Votes that contribute points/tokens/karma towards a total. May be positive or negative.'),
        ),
      ),
      'functions' => array(
        'count' => array(
          'name' => t('Number of votes'),
          'description' => t('The number of votes cast for a given piece of content.'),
        ),
        'average' => array(
          'name' => t('Average vote'),
          'description' => t('The average vote cast on a given piece of content.'),
        ),
        'sum' => array(
          'name' => t('Total score'),
          'description' => t('The sum of all votes for a given piece of content.'),
          'value_types' => array('points'),
        ),
      ),
    );

    \Drupal::moduleHandler()->alter('votingapi_metadata', $data);
  }

  return $data;
}

################
# Code from Andy Post Drupal 8 port
################

/**
 * Implements of hook_menu().
 *
 * @todo Integrate with devel module
 * @todo Upgrade to Drupal 8
 */
//function _votingapi_menu() {
//  $items = array();
//
//  if (module_exists('devel_generate')) {
//    $items['admin/config/development/generate/votingapi'] = array(
//      'title' => 'Generate votes',
//      'description' => 'Generate a given number of votes on site content. Optionally delete existing votes.',
//      'page callback' => 'drupal_get_form',
//      'page arguments' => array('votingapi_generate_votes_form'),
//      'access arguments' => array('administer voting api'),
//      'file' => 'votingapi.admin.inc',
//    );
//  }
//
//  return $items;
//}

/**
 * Cast a vote on a particular piece of content.
 *
 * This function does most of the heavy lifting needed by third-party modules
 * based on VotingAPI. Handles clearing out old votes for a given piece of
 * content, saving the incoming votes, and re-tallying the results given the
 * new data.
 *
 * Modules that need more explicit control can call VotingApi_Vote::saveMultiple() and
 * manage the deletion/recalculation tasks manually.
 *
 * @param array|object $votes
 *   An array of (or a single) VotingApi_Vote objects
 * @param array $criteria
 *   An array of (or a single) VotingApi_Criteria objects used to determine what
 *   votes will be deleted when the current vote is cast. If no value is specified,
 *   all votes for the current content by the current user will be reset. If an empty object is
 *   passed in, no votes will be reset and all incoming votes will be saved IN ADDITION to
 *   existing ones.
 *
 * @return array
 *   An array of vote result records affected by the vote. The values are
 *   contained in a nested array keyed thusly:
 *   $value = $results[$entity_type][$entity_id][$tag][$value_type][$function]
 *
 * @see VotingApi_Vote::saveMultiple()
 * @see votingapi_recalculate_results()
 */
function votingapi_set_votes(&$votes, $criteria = NULL) {
  //  $touched = array();
  //  if (is_object($votes)) {
  //    $votes = array($votes);
  //  }
  //
  //  // Handle clearing out old votes if they exist.
  //  if (!isset($criteria)) {
  //    // If the calling function didn't explicitly set criteria for vote deletion,
  //    // build up the delete queries here.
  //    foreach ($votes as $vote) {
  //      $tmp = new Criteria($vote);
  //      if (isset($tmp->value)) {
  //        $tmp->value = NULL;
  //      }
  //      $tmp->delete();
  //    }
  //  }
  //  else {
  //    if (is_object($criteria)) {
  //      $criteria = array($criteria);
  //    }
  //    foreach ($criteria as $c) {
  //      $c->delete();
  //    }
  //  }
  //
  //  // Cast the actual votes, inserting them into the table.
  //  Vote::saveMultiple($votes);
  //
  //  foreach ($votes as $vote) {
  //    $touched[$vote->entity_type][$vote->entity_id] = TRUE;
  //  }
  //
  //  if (\Drupal::config('votingapi.settings')
  //      ->get('calculation_schedule') != 'cron'
  //  ) {
  //    foreach ($touched as $type => $ids) {
  //      foreach ($ids as $id => $bool) {
  //        $touched[$type][$id] = votingapi_recalculate_results($type, $id);
  //      }
  //    }
  //  }
  //  return $touched;
}